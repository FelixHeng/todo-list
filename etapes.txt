1) TodoApp.js : manage the state of all the todos
- TodoApp
    -TodoForm
    -TodoList
        -TodoItem

every todo need to have an : id, task & completed
we write an initialTodos, and pass it in the useState(initialTodos)
- we start by just rendering the <TodoList todos={todos} />
we pass in todos that we have in useState

2) make a TodoList.js component
we first just want to render a list 
  return (
    <Paper>
      <List>
        {todos.map(todo => (
          <>
            <ListItem>
              <ListItemText>{todo.task}</ListItemText>
            </ListItem>
            <Divider />
          </>
        ))}
      </List>
    </Paper>
  );

3) we make a TodoForm.js now
we need to make our own custom hook in useInputState.js, to add a reset
in TodoApp, we add a addTodo :
  const addTodo = newTodoText => {
    setTodos([...todos, { id: 4, task: newTodoText, completed: false }]);
  };

4) we now gonna add a TodoItem in that component we'll add buttons for :
delete, edit with the logic to toggle the edit form, a checkbox
we need to set the key in each todo key={todo.id} and a completed props
we move the ListItem from the TodoList to the TodoItem
we import the checkbox from material Ui 
tabIndex{-1} mean : 
    When adding a positive value to the tabindex attribute (for example tabindex = "1", tabindex = "2") those elements are reachable by keyboard navigation and the order is defined by the value of the attribute.
    When adding a negative value to tabindex (usually tabindex="-1") it means the element is not reachable by the keyboard navigation, but can be focused using focus function in JS
    A tabindex="-1" value removes the element from the default navigation flow (i.e., a user cannot tab to it), but it allows it to receive programmatic focus, meaning focus can be set to it from a link or with scripting.** This can be very useful for elements that should not be tabbed to, but that may need to have focus set to them.
we import the IconButton, and the DeleteIcon to go in the IconButton and the ListItemSecondaryAction that allow us to have some buttons or content on the other right side
aria-label : c'est pour définir une légende non-visible pour les utilisateurs non voyant ou mal voyant qui utilise un screen-reader
then we set a line-through if the task is completed, the buttons is not connected yet, this is our next task todo

5) we now make the toggling and deletion work with hooks
we're going to define a method up in the parent component TodoApp.js where we're managing the todo state
so we call a removeTodo method and there is 2 function, filter and call setTodos with new todos array 
    const removeTodo = todoId => {
        // filter out removed todo
        // call setTodos with new todos array
    }
to use that filter, for each todo in that array we're going to compare todoId to the todo.id
so the ID on each todo not equal to the todoId, so that filter out the one todo we're trying to remove 
we need to pass a props removeTodo in the TodoApp -> TodoList -> TodoItem 
in the TodoItem we add a removeTodo(id) it's the id we passed in the TodoList id={todo.id}
for now if we add multiple new todos because all of these have an ID of 4 we hard coded it in the TodoApp.js
we need to add in an unique ID with uuid
in the TodoApp we replace the id: 4 by id: uuid() (of course we need to import uuid)
it works we can delete a single todo, each item have an unique id thanks to uuid 
## the checkbox
let's do the same for the checkbox, we want to update the todo when we click on it, let's define the method first
toggleTodo : we gonna do the same thing
for each Todo we gonna check if the todo.id === todoId we passed in and if it is
we gonna return the existing ...todo and toggle the todo's completed status (completed = !todo.completed)
otherwise we just return the todo as it is, then we setTodos with updatedTodos
then we need to pass props toggleTodo={toggleTodo} to TodoApp -> TodoList -> TodoItem

6) we now work with the Editform
1st : we need to toggle the editform true to false and false to true
  we create a new hooks to toggle the state, and import it in the TodoItem 
  const [isEditing, toggle] = useToggleState(false); and pass a props in the edit button
  we make a ternary to show the editingform OR the Todo with the checkbox, remove and editing button  
2nd : we create a new component EditTodoForm.js, to have a textField to edit and we put the component in the TodoItem when editing is True.
  but nothing happens when we hit enter, so let's make our input works
3rd : we have a hooks useInputState which can help us to controle the textField in the EditTodoForm
  in the EditTodoForm we can import the useInputState hooks, that return a value, handleChange and reset 
  now we need to make the method is going to update the Todo when we submit the textField
  so in our TodoApp.js we'll define a new method we called it editTodo 
  we're going to keep the same method as the toggleTodo except once we find the todoId we want to set the task to a newTask
  then we just need to pass this props in the TodoApp -> TodoList -> TodoItem
  and finally in the EditTodoForm we have a props being passed called {editTodo} and we need to call it when we hit "enter" when we submit this
  we have 3 solutions to do that :
    1) we can add a button that we click to save
    2) we can add an event listener and if we press "enter" it will save
    3) we can add a form around the whole thing, and submit it by pressing "enter" key
so let's make a form, we pass in and id, and the value of the TextField
to access to the id we go in the TodoItem and pass it in the EditTodoForm
to show the previews task we need to pass it in the initialvalue in the useInputState(task), don't forget to pass it as a props in the EditTodoForm
we have another issue now, when we hit enter, the form does submit and the reset happens, the todo maybe updated but we're seeing this form so how to hide this form when the toggle state is actually happening in the parent component TodoItem
we can just pass toggle in the TodoItem as a props and grab the props and pass it in the EditTodoForm
in the editform we can add an autofocus, so when we click the edit button we automatically get into the text field 








